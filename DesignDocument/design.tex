\documentclass[letterpaper,10pt,titlepage,draftclsnofoot,onecolumn,onesided] {IEEEtran}
\usepackage{listings}
\usepackage{underscore}
\usepackage[bookmarks=true]{hyperref}
\usepackage[utf8]{inputenc}
\usepackage[english]{babel}
\usepackage{titling}
\usepackage{graphicx}
\usepackage[noadjust]{cite}
\nocite{*}
\usepackage{abstract}

% C: I added this package for the definitions portion of the document
\usepackage{amsthm}

\hypersetup{
    bookmarks=false,    % show bookmarks bar?
    pdftitle={Design Document},    % title
    pdfauthor={Cramer Smith, Sam Lichlyter, Eric Winkler, Zach Schneider},                     % author
    pdfsubject={Design Document},                        % subject of the document
    pdfkeywords={IFT, Design, Postal}, % list of keywords
    colorlinks=true,       % false: boxed links; true: colored links
    linkcolor=black,       % color of internal links
    citecolor=black,       % color of links to bibliography
    filecolor=black,        % color of file links
    urlcolor=blue,        % color of external links
    linktoc=page            % only page is linked
} 

% Document Title:
\def\doctitle{A Tool to Automatically Organize the Structure of a Codebase Using Information Foraging Theory Design Patterns}
\def\doctype{Design Document}
\def\team{Team Postal | Group \#38}

\markboth{Oregon State University}{\doctitle}

\begin{document}

\title{\Huge{\bfseries{\textsf{\doctitle}}}\\\textsf{\Large{\doctype}}\\\textsf{\large{\team}}}
\author{Cramer Smith, Sam Lichlyter, Eric Winkler, Zach Schneider}

\maketitle
\vfill
%\begin{abstract}
%\end{abstract}
\vfill

\pagebreak

\tableofcontents

\pagebreak

% 1
\section{Overview}

% 1.1 
\subsection{Scope}
This document will cover the entirety design of the Postal extension written for the Visual Studio Code integrated development environment. 
The focus of the design will be on the four main parts of the extension, and the use of Information Foraging Theory within the extension.
The four parts of the extension design are the parser, the data structure, the interface with Visual Studio Code and the user interface.
The document with go through each of these parts and describe in detail how each will be implemented and how each part will function.
The Information Foraging Theory Patters that are planned to be explored within the extension are the Specification Matcher, Structural Relatedness, Impact Location, Path Search, and Recollection.
The document will go into more detail as to what these patterns mean and how they will influence the design of the extension.

% 1.2
\subsection{Purpose}
This design document describes the planned design and steps for implementing the Postal extension for Visual Studio Code. 
The team implementing the design will use this document as the blueprint for the implementation of the extension. 

% 1.3
\subsection{Intended Audience}
This document is meant for the design stakeholders. 
The design stake holders includes the team implementing the extension, their client, and their supervisors. 
The teams supervisors being the people grading the project on the implementation of the designs described within this document.


% 1.4 
\subsection{Conformance}
The document conforms to the IEEE Std 1016-2009.

% 2
\section{Definitions}
\newtheorem{VSC}{An acronym of Visual Studio Code. Visaul Studio Code is the IDE for which the postal extension is being built.}
\newtheorem{IDE}{An acronym of Integrated Development Environment.}
\newtheorem{UI}{An acronym of User Interface}
\newtheorem{MVC}{Model-View-Controller (MVC) design pattern assigns objects in an application one of three roles: model, view, or controller. The pattern defines not only the roles objects play in the application, it defines the way objects communicate with each other. Each of the three types of objects is separated from the others by abstract boundaries and communicates with objects of the other types across those boundaries. The collection of objects of a certain MVC type in an application is sometimes referred to as a layerâ€”for example, model layer.\cite{appleMVC}}

% 3
\section{Conceptual Model for Software Design Descriptions}
The software will be loosely written with a model view control design pattern.
It is loosely MVC because it is an extension and some of the view will be out of the control of the extension, but the main parts of the extension will fill these roles .
The model will be the data structure that we will use to represent the parsed files. 
The view will be the user interface and the integrated development environment.
The IDE and the user interface that the extension creates will be the view and act dependent of each other.
The control will be the event handlers that are 

% 3.1
\subsection{Software Design in Context}
The extension is supposed to help novice web developer with organizing and create cleaner HTML and CSS code. 
To accomplish this the design of the extension it will contain a UI, a number of parsers for the different languages.
The parsers and the extensions will need to communicate between each other and VSC.
This communication will be facilitated by a datastructer that will also allow for a 



% 3.2
\subsection{Software Design Descriptions Within the Life Cycle}
\subsubsection{Influences on SDD Preparation}
\subsubsection{Influences on Software Life Cycle Products}
\subsubsection{Design Verification and Design Role in Validation}

% 4
\section{Design Description Information Content}

% 4.1
\subsection{Introduction}

% 4.2
\subsection{SDD identification}

% 4.3
\subsection{Design stakeholders and their concerns}

% 4.4
\subsection{Design views}

% 4.5
\subsection{Design viewpoints}


% 4.6
\subsection{Design Overlays}

% 4.7
\subsection{Design Rationale}

% 4.8
\subsection{Design Languages}




% 5.2

% 5.3

\section{Composition Viewpoint}
\subsubsection{Design Concerns}
\subsubsection{Design Elements}
	Extension
	type: system
	
	Parser
	type: component
	
	Ui
	type: component
	
	data handling (datstructure, saving)
	type: component
	
% 5.4
\section{Logical Viewpoint}
	logical thigns like classes
\subsubsection{Design Concerns}
\subsubsection{Design Elements}
	Parser

	Ui

	datahandling (datstructure, saving)


% 5.6
\section{Information Viewpoint}
\subsubsection{Design Concerns}
\subsubsection{Design Elements}
	Dictionary
	
	FileNodes
		fileName
		file type ect.
		
	Errors
		line number
		error string.




% 5.8
\section{Interface Viewpoints}
\subsubsection{Design Concerns}
\subsubsection{Design Elements}
	IDE
		exposes
		requires
	
	Parsers
		exposes
		requires
	
	DataStructure
		exposes
		requires
	
	UI
		exposes
		requires
		
	Files
		exposes
		requires


% 5.10
\section{Interaction Viewpoints}
\subsubsection{Design Concerns}
The concern that come with using these events is that we might not be the correct events that the extension needs to be listening to. 
It could be that doing the parse on every save will slow down the developement process too much. 
If that were the case there would have a specific command that the user would need to input every time that they would want to use the Postal Extension.
This senario would greatly decrease the usability of the extension by adding an unnessesary step to the process.

\subsubsection{Design Elements}
	-----Parse Files on savebox
	
There are several actions that occur within VSCode that will initiate the extension parcing and interpretting process.
These events will be specific events that will have specific listeners. 
Each event will trigger a specific type of the same process.
These events are when the user starts the use of the extension, when the user explicitly saves one or all the files, and when the user closes the application.
When the user starts the extension the extension will the first initial parsing and create the datastructer that will serve as a reference for the next continuation of the extension.
This first parsing will be set in motion by the built-in activate function. 
After the initialization whenever the user saves the files the extension is planned to parse the files and get the nessesary information to parse once again. 
The extension will only continue on the explicit saves, meaning only when the user to saves the files, rather then when VSC auto saves. 
Once the user saves the files the inPerSaveDocument listener will be acted upon.
This should trigger the parser and continue the extension process, but it will continue it before it has actually saved the documents. 
This will allow for possible formatting of the user's code before it is saved.
Then when the user closes the VSC application or kills the extension then the deactivate listener will do one last parse of the files so that the user will be where they left next time they comeback to the project.
These three events should be able cover the major of instances when the extension is expected to be iterated.


	-----open UI vs code command
	
When the a parsing of the files happens it is important for the extension to know what has change in the user current work space. 
	
	
	-----Open error object

% Annex A  Bibliography
% Annex B  Conforming design language description
% Annex C  Annex C Templates for an SDD

%\section{Conclusion}


\pagebreak
\bibliographystyle{IEEEtran}
\bibliography{techreview}

\end{document}
