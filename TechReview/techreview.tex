\documentclass[letterpaper,10pt,titlepage,draftclsnofoot,onecolumn,onesided] {IEEEtran}
\usepackage{listings}
\usepackage{underscore}
\usepackage[bookmarks=true]{hyperref}
\usepackage[utf8]{inputenc}
\usepackage[english]{babel}
\usepackage{hyperref}
\usepackage{titling}
\usepackage{graphicx}
\usepackage[noadjust]{cite}
\nocite{*}
\usepackage{abstract}



\hypersetup{
    bookmarks=false,    % show bookmarks bar?
    pdftitle={Technology Review},    % title
    pdfauthor={Cramer Smith, Sam Lichlyter, Eric Winkler, Zach Schneider},                     % author
    pdfsubject={Technology Review Document},                        % subject of the document
    pdfkeywords={IFT, TechReview, Postal}, % list of keywords
    colorlinks=true,       % false: boxed links; true: colored links
    linkcolor=black,       % color of internal links
    citecolor=black,       % color of links to bibliography
    filecolor=black,        % color of file links
    urlcolor=blue,        % color of external links
    linktoc=page            % only page is linked
} 

% Document Title:
\def\doctitle{A Tool to Automatically Organize the Structure of a Codebase Using Information Foraging Theory Design Patterns}
\def\doctype{Technology Review and Implmentation Plan}
\def\team{Team Postal}

\markboth{Oregon State University}{\doctitle}

\begin{document}

\title{\Huge{\bfseries{\textsf{\doctitle}}}\\\textsf{\Large{\doctype}}\\\textsf{\large{\team}}}
\author{Cramer Smith, Sam Lichlyter, Eric Winkler, Zach Schneider}

\maketitle
\vfill
\begin{abstract}


\end{abstract}
\vfill

\pagebreak

\tableofcontents

\pagebreak

\section{Introduction}


\section{Sam Lichlyter}

\subsection{Piece 1}
\subsubsection{Technology 1}
\subsubsection{Technology 2}
\subsubsection{Technology 3}

\subsection{Piece 2}
\subsubsection{Technology 1}
\subsubsection{Technology 2}
\subsubsection{Technology 3}

\subsection{Piece 3}
\subsubsection{Technology 1}
\subsubsection{Technology 2}
\subsubsection{Technology 3}


\section{Zach Schneider}
\subsection{Data Structure Serialization and Storage}
The text editor extension created for this project function in part by parsing an existing code base. 
The parsed code base will be converted into a sort of data structure that can be more easily utilized and manipulated for helping the user, while not interfering with their actual files. 
The user's code base will be parsed periodically, but that parse function may be resource intensive, and as such, serialization of the parsed data into a more accessible form will be required. 
JSON.stringify, a mongoDB database, and the serialize-javascript npm package will be considered for the serialization of our data structure.

\subsubsection{JSON.stringify}
Since the text editor will be written in JavaScript or a superset of it, using JSON as the method of storing objects seems the most obvious. 
JSON text is valid JavaScript code and is supported in many modern languages and IDEs. 
JSON is also plaintext, which requires significantly less overhead and space than a full database. 
As of the ECMAScript 5.1 standard (2011), the JSON object in JavaScript has a built in stringify and parse function, which will serialize and deserialize JavaScript variables and object respectively. 
As this function has been officially supported for many years and has multiple sources of documentation and example usage online, it will be the primary choice for how the extension stores files related to user projects. \cite{stringify}

\subsubsection{serialize-javascript}
A shortcoming of JSON.stringify is that it does not allow actual JavaScript functions to be serialized into JSON, nor does it allow regular expression statements. 
The serialize-javascript npm package serves as a superset of JSON.stringify while also including the aforementioned functionality. 
Additionally, serialize-javascript will auto escape HTML code, making the JSON  safe to display on webpages in raw form. 
Npm is supported by dozens of IDEs and text editors, so compatibility will not likely be a problem. 
The largest drawback of using serialize-javascript is its lack of documentation, despite its mild popularity. 
There are fewer examples of its usage online than JSON.stringify, and it adds another external dependency to our extension. 
For these reasons, serialize-javascript will not be a part of the storage system in the extension. \cite{serialize}

\subsubsection{MongoDB}
MongoDB is a free and open-source database solution that uses JSON-like documents for storing data. 
It is a NoSQL database, meaning it differs from typical SQL-based relational schema systems. 
It is commonly used in big-data or real-time applications, often used in conjunction with node.js and other JavaScript technologies our development team is familiar with. 
MongoDB is supported on numerous cloud and local platforms, scaling from small local uses to large server applications. 
The two main drawbacks for using MongoDB is that it has a large overhead to install (hundreds of megabytes) and none of our team members have used a NoSQL database before. 
For this unfamiliarity and space requirement, our team has opted not to use MongoDB to serialize our extension data. \cite{mongo}

\subsection{Piece 2}
\subsubsection{Technology 1}
\subsubsection{Technology 2}
\subsubsection{Technology 3}

\subsection{Piece 3}
\subsubsection{Technology 1}
\subsubsection{Technology 2}
\subsubsection{Technology 3}


\section{Cramer Smith}
%  ___ ___  ___ 
% |_ _|   \| __|___
%  | || |) | _|(_-<
% |___|___/|___/__/  	Please keep this I have trouble keeping where I am
%
\subsection{The Best Base Integrate Developement Enviroment} 
It is nesecary to look all the possible integrated developement environments for the postal project to see what would be the best fit for this specific extension, both developement wise and release wise.
To this purpose this review will examine three IDEs that could all be used as the base of the extension that is plannned to be implemented.
Those IDEs are Brackets, Atom, and Visual Studio Code (VSCode) all of which have there advantages and disadvantages.

\subsubsection{Brackets}
Brackets is a text editor owned by Adobe, and is currently in development as an open source project. \cite{Brackets}
Brackets is made specifically for web development, and offers tools such as the Chrome debugger, inline editor, and live website previewer built in.
The research into the Brackets IDE has brought to attention many features that were good but also some that were not as good.
Adobe started the developement in 2011 making Brackets the oldest of the IDEs that are examined in this paper meaning it is the most established and it has had more time to become a more stable build. 
The longer life of Brackets could also explain the more extensive documentation that it has when compared to other IDEs extension development documentation.
Another nice feature of Brackets is that it has dedicated API functionality that allows for extensions to safely modify the underlying Document Object Map (DOM) which would be advantagous to have that ability.
While there are several benefits to Brackets there are some drawbacks specifically being the extension debugging and lack of usability in the extension manager. 
The extension debugging consists of having another development environment open with the extensions code and restarting Brackets with every change.
This restarting will get tedious after prolonged developement.
The extension manager in brackets is not user friendly, it is basically a list of extensions and a search bar.
With the target audience we are hoping to reach we think that the extensions need to be more readily available and easier to understand. 

\subsubsection{Atom}
Atom is a text editor developed by GitHub that is currently in development as an open source project. 
It features cross platform editing, a built in package manager, and smart auto completion.
Atom advertises itself as the \'hackable\' text editor meaning that it is made using HTML, CSS and JavaScript in such a way that anyone is using the text editor for web development then they should be able to develop for Atom. \cite{Atom}
This is a commonality between all of the possible IDEs.
Atom is actually what VSCode from, but VSCode added TypeScript to the languages that it is built in.
While atom is a good has a editor and auto completion it does not stand out when compared to the other IDEs. 
In fact it seems as though Atom uses extensions as a crutch not implementing built in functionality requiring the user to get extensions in order to complete their tasks. 
While this does make the initial learning curve of using Atom a bit larger it does keep the editor light and running very fast.

\subsubsection{Visual Studio Code}
Visual Studio Code is an editor by Microsoft, and it was the editor that was initially proposed as the base of the extenstion. \cite{VSCode}
This initial idea to use VSCode was a product of the team having worked with Visual Studio and enjoying the experience. 
Now that the team has tried working with Visual Studio Code there has been some benefits and drawbacks identified. 
The benefits were that VSCode has justifiably better extension debugging than the other IDEs available. 
VSCode seems to build around the idea that people will be making extensions for Visual Studio Code so there is a development window that is created when debugging extension code within VSCode. 
The other IDEs seem to be less approachable with a system that makes the developer reinitialize the IDE every time the extension's code is changed. 
The other benefit of using VSCode was that the extension can be written using TypeScript, but that being said none of the team members have used TypeScript meaning it would be additional learning curve added on to the obstacle of learning more JavaScript. 
The first of the drawbacks of VSCode become evident when working with the documentation and finding that Visual Code is fairly new, and does not have a lot of documentation or examples of extensions to readily examine. 
As this team is fairly new to creating extensions and not efficient at writing in JavaScript this was going to be a problem. 
Visual Studio Code also had no built in API for modifying underlying DOM that make up the main user interface which the postal extension plans on doing extensively.

\subsubsection{Decision}
All this being said the team has decided to use Visual Studio Code based on several major benefits. 
Visual Studio Code's use of TypeScript and being able to import .NET librarys. 
All of the team members have at least some experience with .NET libraries, and these could be used to greatly imporve the project. 
The Visual Studio Code also has the best Extension Debugger than the other IDEs and a more defined extension creation process.
This is important for the integrity of the developement of the extension in the long run. 
Visual Studio Code has a extension creation guides the developer through the process of making the extension and creates all the helper files that the developer will need in their extension.
The other benefit is that the built in extension manager will be easy for the user to manage than the other IDEs. 

%  ___             _      
% | __|_ _____ _ _| |_ ___
% | _|\ V / -_) ' \  _(_-<
% |___|\_/\___|_||_\__/__/ 		The events that the IDE will be listening 
%
\subsection{Event Handling Within A Seperate Window of the IDE}
Visual Studio Code is going to interface with the user and our extension will need to know what the user is doing.
The specific instance that this portion focuses on the the event handler that the IDE is actively listening for from it's extension.
The Postal extension needs a way of getting information from the extension, this section will explore the options that the VSCode extension API offers developers for this kind of interaction. 
The events that the IDE will be listening 

\subsubsection{HTML Preview Links}
The first way that VSCode makes it possible to have events is through the HTML Previewer. \cite{VSCode Documentation} 
This method would require that the extension makes an HTML page and then display that page either in a web browser or using the built in command previewHtml using the vscode.executeCommand() and passing it an Uniform Resource Identifier (URI). 
The URI that would be past to the command would have a HTML DOM that would be rendered in a seperate panel on top of the VSCode's HTML and CSS. 
This seems like an easy way of creating a user interphase, but the only interactable element would be links. 
Links would only be able to change the the view to other HTML files. 
The idea of making every possible use case a seperate HTML file would be difficult without the use of PHP.
\subsubsection{EventEmitter}
The better option would be to use the VSCodes EventEmitter to create and manage for other to subscribe to. 
With an eventEmitter the extension can create listeners that can then be listen for when the event fires signifying to the listeners that the event has occurred. 
This is the intended way that exentions are supposed to create and the event handlers. 
There are also built in events that the these event listeners will need to be initialized before the user actually interfaces with the extension and to do that the extension will need to use the activation events. 
An activation event is set in the package.json of the extension and these activation events are sent from the IDE to the extensions.
These events can be onLanguage, onCommand, onDebug, workspaceContains or a star (*) signifying that the extension should always be running. 
When the extension recieves one of these events that it is listening for it will start the extension operations. 
Setting these custom eventEmitters and event listeners should be the first thing that the extension sets up as they will be very important for the interface that the user will interacet with. \cite{VSCode Documentation}

\subsubSection{Desicion}
For the purpose of this project the eventEmmiter and Listener will be used for obvious reasons. 
The first being that it is the standard of Visual Studio. 
The second reason being that the HTML preview would be extremely tedious and impractical.

%  _                                         
% | |   __ _ _ _  __ _ _  _ __ _ __ _ ___ ___
% | |__/ _` | ' \/ _` | || / _` / _` / -_|_-<
% |____\__,_|_||_\__, |\_,_\__,_\__, \___/__/ 		The Languages that the Visual Studio uses. 
%						|___/          |___/        
\subsection{Languages Exetensions Written in}
\subsubsection{JavaScript}
With all the possible IDEs the extension can be written in JavaScript and correspnding JSON files. 
JavaSctipt was created in 10 days in 1995, is a well known and well documented language. \cite{JavaScript History}
\subsubsection{TypeScript}
TypeScript is a language created by Microsoft in \cite{TypeScript}


\section{Eric Winkler}
\subsection{Piece 1}
\subsubsection{Technology 1}
\subsubsection{Technology 2}
\subsubsection{Technology 3}

\subsection{Piece 2}
\subsubsection{Technology 1}
\subsubsection{Technology 2}
\subsubsection{Technology 3}

\subsection{Piece 3}
\subsubsection{Technology 1}
\subsubsection{Technology 2}
\subsubsection{Technology 3}

\section{Conclusion}

\bibliographystyle{IEEEtran}
\bibliography{techreview}

\end{document}
